\documentclass[a4paper, 14pt]{extarticle}

\input{preamble}

\begin{document}

\input{title}

% \title{Доказуемо надёжные в слабом смысле трудные биты \\[0.5cm] \large Дипломная работа}
% \author{Автор: Олейников Иван \and Научный руководитель: \\ Гирш Эдуард Алексеевич}
% \date{\today}
% \maketitle

\abstract{В этой работе вводится определение надёжного в слабом смысле трудного
бита, а также приводятся конструкции таких трудных битов для некоторых линейных
функций.

Надёжным в слабом смысле трудным битом для биективной булевой функции $f$ здесь
называется такая функция $h$, что вычислить $h(x)$ по заданному $f(x)$ (то есть
вычислить $h \circ f^{-1}$) как минимум в константу раз труднее, чем вычислить
$f(x)$ или $h(x)$ по заданному $x$. Под трудностью функции здесь понимается
размер минимальной вычисляющей её схемы из произвольных гейтов арности $2$.

Функции, для которых в этой работе строится надёжный в слабом смысле трудный
бит, основаны на надёжных в слабом смысле односторонних функциях из прошлых
работ А. Хильтгена \cite{hiltgen1993,hiltgen1994}. Надёжная в слабом смысле
односторонняя функция "--- это такая функция, обратить которую как минимум в
константу раз труднее, чем вычислить её значение в точке.}

\tableofcontents

\section*{Введение}
\addcontentsline{toc}{section}{Введение}

Неформально говоря, односторонней функцией является такая функция $f$, вычислить
которую в любой точке $x$ легко, но по значению которой $f(x)$ трудно найти
такую точку, в которой функция примет это значение \cite{goldreich}. Это
иллюстрируется рисунком \ref{fig_owf}, пунктирная стрелка обозначает задачу
противника, которая должна быть сложной, а сплошная "--- задачу честного
пользователя, которая должна быть простой.

\begin{figure}[h]
\centering
\includegraphics{standalone/figure_owf}
\caption{Диаграмма односторонней функции $f$}
\label{fig_owf}
\end{figure}

Односторонние функции являются базовым криптографическим примитивом для
построения построения других, таких как псевдослучайные генераторы, протоколы
привязки \begin{foreignlanguage}{english}(bit commitment)\end{foreignlanguage},
шифрование с секретным ключом и цифровая подпись. В настоящее время неизвестно
ни одной конструкции односторонней функции, для которой была бы безусловно
доказана надёжность. Более того неизвестно даже, существуют ли такие функции.
Что вовсе не удивительно, ведь если доказать существование односторонних
функций, это позволит решить некоторые давно открытые вопросы теории
сложности, к примеру, из их существования будет следовать $\NP \nsubseteq
\BPP$ и, следовательно, $\P \neq \NP$ \cite{goldreich}.

Поэтому надежды на то, что для какой-то функции будет доказано, что она является
односторонней, мало. И все известные утверждения о надёжности односторонних
функций доказываются условно, исходя из некоторых популярных предположений.

Раз не удаётся доказать надёжность ни для какой односторонней функции в
классическом её определении, то быть может её удастся доказать, если выбрать
другое определение с более слабыми требованиями? Именно такой вопрос исследовал
А. Хильтген в своих работах \cite{hiltgen1993,hiltgen1994}.

Хильтген предложил определить надёжную в слабом смысле одностороннюю
перестановку порядка $k$ как перестановку $f_n : \{0, 1\}^n \to \{0, 1\}^n$,
обратить которую примерно в $k$ раз <<сложнее>>, чем вычислить её: $C(f_n^{-1})
\geq (k - o(1)) \cdot C(f_n)$. Сложностью $C(f)$ здесь называется минимальный
размер булевой схемы из бинарных гейтов, вычисляющей функцию $f$. Кроме того,
Хильтген построил линейные односторонние перестановки со слабой надёжностью
порядка $3/2$ и $2$, а также нелинейную порядка $2$.

Предложенное Хильтгеном определение слабой надёжности схоже с классическим
определением в том, что оба определения требуют, чтобы задача противника "---
вычисление $f_n^{-1}$ решалась <<труднее>>, чем задача честного пользователя
"--- вычисление $f_n$. Отличие этих определений в том, что они по-разному
уточняют, что означает <<труднее>>: слабая надёжность требует, чтобы сложности
функций отличались в константу раз; а классическое определение требует, чтобы
эти сложности отличались на суперполиномиальный множитель, и в то же время
противнику разрешается корректно вычислять $f_n^{-1}$ лишь в среднем случае
"--- на доле $1 / \poly(n)$ от всех входов, а на всех остальных ему позволено
ошибаться.

Такие надёжные в слабом смысле криптографические примитивы, разумеется, не
рассчитаны на практическое применение. Цель их изучения в том, чтобы понять,
где именно сейчас находится граница надёжности, которую мы можем доказывать
безусловно. К тому же, изучение таких конструкций может дать новые идеи, при
помощи которых в будущем могут быть построены более сильные конструкции. Более
подробное обсуждение мотивации для таких конструкций можно найти в первых работах
Хильтгена \cite{hiltgen1993,hiltgen1994}.

Определения надёжности в слабом смысле для других криптографических примитивов,
предложенные в следующих работах \cite{HN09,DN11,hirsch_milanich_nikolenko},
как и предложенное в этой дипломной работе, схожи с определением Хильтгена для
односторонних функций и точно так же требуют, чтобы задачи противника были в
константу раз труднее задач честных пользователей. Но в отличие от определения
Хильтгена, определения из последующих работ позволяют противнику ошибаться на
некоторой константной доле входов.

В следующих за Хильтгеном работах о надёжности в слабом смысле предлагались
определения надёжности и конструкции односторонних функций с секретом
(\begin{foreignlanguage}{english}trapdoor function\end{foreignlanguage}). В
работах \cite{HN09,hirsch_milanich_nikolenko} Э. А. Гирш, О. Ю. Меланич и С. И.
Николенко предложили определение надёжной в слабом смысле односторонней функции
с секретом, схожее с определением Хильтгена для односторонней функции. Они
также привели линейную конструкцию с надёжностью порядка $25/22$ и нелинейную
с надёжностью $7/5$. Затем \cite{DN11} А. П. Давыдов и С. И. Николенко привели
линейную конструкцию слабо надёжной односторонней функции с секретом порядка
$5/4$.

В этой дипломной работе предлагается определение надёжного в слабом
смысле трудного бита (\begin{foreignlanguage}{english}hard-core
predicate\end{foreignlanguage}) для функции. Неформально можно определить
трудный бит для функции $f$ как такую функцию $h$, что вычислить $f(x)$ и
$h(x)$ по заданному $x$ легко, но вычислить $h(x)$ по заданному $f(x)$ трудно
\cite{goldreich}. Это иллюстрируется рисунком \ref{fig_hp}, задачи честного
пользователя обозначены сплошными стрелками, а задача противника "---
пунктирной.

\begin{figure}[h]
\centering
\includegraphics{standalone/figure_hp}
\caption{Диаграмма функции $f$ и её трудного бита $h$}
\label{fig_hp}
\end{figure}

% Что ещё строится?
В классической криптографии трудный бит является промежуточным примитивом,
используя его и одностороннюю функцию строится, к примеру, псевдослучайный
генератор.

Кроме определения, в этой работе также приводится несколько конструкций трудного
бита. Функции $f$, для которых строятся трудные биты $h$, основаны на линейных
односторонних функциях из работ Хильтгена.

В работе О. Голдрейха и Л. Левина \cite{goldreich_levin} была впервые применена
одна очень простая техника для построения односторонней перестановки, имеющей
трудный бит, (в классическом определении) из любой односторонней перестановки.
Если $f' : \{0, 1\}^n \to \{0, 1\}^n$ "--- односторонняя перестановка, то
преобразуем её в перестановку $f$, добавив ещё $n$ входов, которые будут
подаваться на выход неизменными: $f(x, y) = (x, f'(y))$. Голдрейх и Левин
доказали, что скалярное произведение $h(x, y) = \ang{x, y}$ является трудным
битом для односторонней перестановки $f$.

Такая же конструкция испольуется в этой дипломной работе для получения
односторонней перестановки и трудного бита для неё (надёжных в слабом смысле) из
односторонней перестановки, построенной Хильтгеном в \cite{hiltgen1993}.

Несмотря на схожесть построенной в этой дипломной работе конструкции с
конструкцией Голдрейха и Левина, доказательства надёжности (классической
надёжности у Голдрейха и Левина, и надёжности в слабом смысле в этой
дипломной работе) для них совсем непохожи. В этой работе для доказательства
используется техника удаления гейтов (\begin{foreignlanguage}{english}gate
elimination\end{foreignlanguage}), применением которой доказаны все известные
сейчас нижние оценки на схемную сложность.

В следующей секции \ref{sec_defs} даются все нужные далее определения, включая
определение надёжного в слабом смысле трудного бита и схемной сложности.
В секции \ref{sec_hiltgen} описывается семейство надёжных в слабом смысле
односторонних функций из работы Хильтгена, приводятся построенные Хильтгеном
доказательства их надёжности, а также описывается связь конструкций Хильтгена
с приводимыми в этой работе конструкциями. Затем в секции \ref{sec_bound}
приводится нижняя оценка на сложность задачи противника. Наконец в секции
\ref{sec_corr} подводится итог работы и описываются следствия из оценок
сложности.

\section{Определения}
\label{sec_defs}

В качестве модели вычислений мы будем использовать булевы схемы, гейты которых
вычисляют произвольные функции двух аргументов. Именно эта модель используется
предыдущими работами по надёжным в слабом смысле криптографическим примитивам.
Подробное обсуждение выбора модели можно найти в работе \cite{hiltgen1994}.

Кратко напомним определение схемы (подробнее смотрите в книге \cite{jukna}).

\begin{definition}
Булевой схемой называется ациклический ориентированный граф, вершины которого
бывают двух типов:
\begin{itemize}
\item Входы, имеющие входную степень $0$. Каждая такая вершина $v$ помечена
  переменной $x_v$ из набора $x_1$, $x_2$ \dots $x_n$.
\item Гейты, имеющие входную степень $2$. Каждая такая вершина $v$ помечена
  функцией $\phi_v : \{0, 1\}^2 \to \{0, 1\}$.
\end{itemize}

Если заданы значения переменных $x_1$, $x_2$ \dots $x_n$, то их можно по
индукции распространить от помеченных переменными входов по всем гейтам схемы,
положив значение в гейте равным значению записанной в нём функции на значениях,
которыми помечены вершины со входящими в гейт рёбрами.

Выходы схемы "--- это набор переменных $y_1$, $y_2$ \dots $y_m$, для каждой из
которых указано, что она равна либо значению в каком-то гейте, либо она равна
отрицанию значения в каком-то гейте.

Получается, что схема ставит в соответствие каждому набору значений для
переменных $x_1$ \dots $x_n$ набор значений для $y_1$ \dots $y_n$ и, таким
образом, вычисляет функцию $(x_1, x_2 \dots x_n) \mapsto (y_1, y_2 \dots y_m)$
\end{definition}

Для функции $f : \{0, 1\}^n \to \{0, 1\}^m$ символом $C(f)$ обозначается
размер наименьшей схемы, вычисляющей функцию $f$. Похожим образом определяется
схемная сложность в среднем "--- символом $C_\alpha(f)$, где $\alpha \in (0, 1)$,
обозначим размер наименьшей схемы, вычисляющей $f$ на \emph{большей}, чем $\alpha$,
доле всех входов:
\begin{align*}
C_\alpha(f) &= \min_{f' \in F} C(f'), \\
\shortintertext{где $F$ "--- множество всех функций $f'$, для которых}
\abs{\{x \mid f'(x) &= f(x)\}} > \alpha 2^n.
\end{align*}

Ниже приводится определение надёжной в слабом смысле односторонней функции из
работы Хильтгена \cite{hiltgen1993}, оно понадобится нам, чтобы понять связь
конструкции Хильтгена с приводимой в этой работе конструкцией, к тому же на нём
основано определение трудного бита, предлагаемое в конце этой секции.

\begin{definition}[Надёжная в слабом смысле односторонняя функция \cite{hiltgen1993}]
Семейство перестановок $\{f_n\}$, где $f_n : \{0, 1\}^n \to \{0, 1\}^n$,
называется слабо односторонним порядка $k > 1$, если с ростом $n$ схемная
сложность $C(f_n^{-1})$ приближается к $k \cdot C(f_n)$:
\[
\begin{aligned}
&\lim_{l \to \infty} \sup_{n > l} C(f_n) = \infty
&
\text{и}&
&
\lim_{l \to \infty} \sup_{n > l} \frac {C(f_n^{-1})} {C(f_n)} = k&
\end{aligned}
\]
\end{definition}

Как уже иллюстрировалось рисунком \ref{fig_owf}, функция $f_n^{-1}$ задаёт
задачу противника, а функция $f_n$ "--- задачу честного пользователя. Если
теперь перейти к трудному биту, задачи которого изображены на рисунке
\ref{fig_hp}, то можно сформулировать схожее определение и для него. Оно
предлагается ниже.

\begin{definition}[Надёжный в слабом смысле трудный бит]
Предикат $h_n : \{0, 1\}^n \to \{0, 1\}$ будем называть трудным битом порядка
$k$ с вероятностью $\alpha$ для перестановки $f_n : \{0, 1\}^n \to \{0, 1\}^n$,
если
\[
\begin{aligned}
&\lim_{l \to \infty} \sup_{n > l} C(h_n) = \infty
&
\text{и}&
&
\lim_{l \to \infty} \sup_{n > l} \frac {C_\alpha(h_n \circ f_n^{-1})} {\max \{ C(h_n), C(f_n) \}} = k&
\end{aligned}
\]
\end{definition}

Функция $h_n \circ f_n^{-1}$ здесь обозначает задачу противника "--- по
заданному $f_n(x)$ вычислить $h_n(x)$. А функции $h_n$ и $f_n$ "--- это те
задачи, которые решает пользователь трудного бита; он может <<легко>> найти
трудный бит $h_n(x)$ по входу $x$, а также применить ко входу функцию $f_n$. И
определение требует, чтобы соотношение числа операций, совершаемых противником и
пользователем, приближалось к $k$ с ростом $n$. Ещё это определение усиливает
требование к конструкции трудного бита, позволяя противнику корректно вычислять
его функцию $h_n \circ f_n^{-1}$ лишь на большей $\alpha$ доле входов и
ошибаться на всех остальных.

\section{Односторонние перестановки}
\label{sec_hiltgen}

В этой секции делается обзор односторонних функций, надёжных в слабом смысле,
введённых Хильтгеном в \cite{hiltgen1993}. А также описывается построенная в
этой работе конструкция трудного бита, которая основана на функциях Хильтгена.

\subsection{Обзор односторонних перестановок}

Мы будем рассматривать булевы значения как элементы поля $\F = (\{0, 1\}, \land,
\oplus)$, и везде, где такие значения будут складываться или умножаться, будут
подразумеваться операции из поля.

Представим дерево из $n$ вершин и $n - 1$ рёбер. Пусть каждая из его вершин
помечена уникальной булевой переменной из набора $x_1 \dots x_n$, а каждое ребро
"--- уникальной переменной из набора $y_1 \dots y_{n-1}$. Символами $x$ и $y$ без
индексов будем обозначать вектора из таких переменных.

Пример такого дерева изображён на рисунке \ref{fig_tree}.

\begin{figure}[h]
\centering
\begin{tikzpicture}[auto, node distance=2cm, every loop/.style={},
                    thick,main node/.style={circle,draw,font=\sffamily\normalsize\bfseries}]

  \node[main node] (1) [fill=black!15]                  {$x_1$};
  \node[main node] (2) [above left of=1] {$x_2$};
  \node[main node] (3) [left of=2]       {$x_3$};
  \node[main node] (4) [right of=1]      {$x_4$};
  \node[main node] (5) [below left of=1] {$x_5$};
  \node[main node] (6) [right of=5]      {$x_6$};
  \node[main node] (7) [left of=5]       {$x_7$};

  \path[every node/.style={font=\sffamily\normalsize\bfseries}]
    (1) edge [above right] node {$y_1$} (2)
        edge [above] node {$y_3$} (4)
        edge [above left] node {$y_4$} (5);

  \path[every node/.style={font=\sffamily\normalsize\bfseries}]
    (2) edge [above] node {$y_2$} (3);

  \path[every node/.style={font=\sffamily\normalsize\bfseries}]
    (5) edge [above] node {$y_5$} (6)
        edge [above] node {$y_6$} (7);

\end{tikzpicture}
\caption{Пример дерева}
\label{fig_tree}
\end{figure}

Теперь для каждого ребра $y_i$, соединяющего вершины $x_j$ и $x_k$, установим
\[
y_i = x_j + x_k.
\]
После этого по значениям $x$ будут однозначно определены значения $y_1 \dots
y_{n-1}$, а значение $y_n$ "--- пока нет. Чтобы это справить, потребуем, чтобы
выполнялось
\[
x_1 = \sum_{i = 1}^n y_i.
\]

Теперь биты $x$ однозначно определяются по битам $y$:
\[
x_i = x_1 + \sum_{j \in P_i} y_j,
\]
где $P_j$ "--- это номера рёбер на единственном простом пути в дереве из $x_1$ в
$x_j$. Заметим, что каждое значение для $x_i$ содержит слагаемое $y_n$, ведь оно
содержится в $x_1$.

В случае нечётного $n$ значение для $y_n$ можно найти, если рассмотреть сумму
\[
\begin{aligned}
\sum_{i=1}^n x_i &= \underbrace{y_n + \sum_{i=1}^{n-1} y_i}_{x_1} +
\underbrace{\sum_{i = 2}^n \sum_{j \in P_i} y_j}_{x_2 + \dots + x_n}
\\
y_n &= \sum_{i=1}^n x_i - \sum_{i = 1}^{n-1} y_i - \sum_{i = 2}^n \sum_{j \in P_i} y_j, \\
\end{aligned}
\]
затем заменить в правой части все слагаемые $y_1 \dots y_{n-1}$ на их выражения
через ${x_1 \dots x_n}$. В случае нечётного $n$ того же можно добиться, если
к обеим частям первого равенства прибавить $x_1 = \sum_{i=1}^n y_i$. (Явную
формулу для $y_n$ определим позже, пока достаточно просто убедиться, что $y_n$
выражается через $x$.)

Получается, что такое дерево задаёт линейное отображение $x \mapsto y$ и
обратно, $y \mapsto x$. К примеру, для дерева с рисунка \ref{fig_tree}
отображения будут такими:
\[
\begin{aligned}
\begin{bmatrix}
y_1 \\ y_2 \\ y_3 \\ y_4 \\ y_5 \\ y_6 \\ y_7
\end{bmatrix} &= \begin{bmatrix}
\mathbf1 & \mathbf1 & 0 & 0 & 0 & 0 & 0 \\
0 & \mathbf1 & \mathbf1 & 0 & 0 & 0 & 0 \\
\mathbf1 & 0 & 0 & \mathbf1 & 0 & 0 & 0 \\
\mathbf1 & 0 & 0 & 0 & \mathbf1 & 0 & 0 \\
0 & 0 & 0 & 0 & 0 & 0 & 0 \\
0 & 0 & 0 & 0 & \mathbf1 & \mathbf1 & 0 \\
0 & 0 & 0 & 0 & \mathbf1 & 0 & \mathbf1 \\
\end{bmatrix} \begin{bmatrix}
x_1 \\ x_2 \\ x_3 \\ x_4 \\ x_5 \\ x_6 \\ x_7
\end{bmatrix}
\\
\begin{bmatrix}
x_1 \\ x_2 \\ x_3 \\ x_4 \\ x_5 \\ x_6 \\ x_7
\end{bmatrix} &= \begin{bmatrix}
\mathbf 1 & \mathbf 1 & \mathbf 1 & \mathbf 1 & \mathbf 1 & \mathbf 1 & \mathbf 1 \\
0 & \mathbf 1 & \mathbf 1 & \mathbf 1 & \mathbf 1 & \mathbf 1 & \mathbf 1 \\
0 & 0 & \mathbf 1 & \mathbf 1 & \mathbf 1 & \mathbf 1 & \mathbf 1 \\
\mathbf 1 & \mathbf 1 & 0 & \mathbf 1 & \mathbf 1 & \mathbf 1 & \mathbf 1 \\
\mathbf 1 & \mathbf 1 & \mathbf 1 & 0 & \mathbf 1 & \mathbf 1 & \mathbf 1 \\
\mathbf 1 & \mathbf 1 & \mathbf 1 & 0 & 0 & \mathbf 1 & \mathbf 1 \\
\mathbf 1 & \mathbf 1 & \mathbf 1 & 0 & \mathbf 1 & 0 & \mathbf 1 \\
\end{bmatrix} \begin{bmatrix}
y_1 \\ y_2 \\ y_3 \\ y_4 \\ y_5 \\ y_6 \\ y_7
\end{bmatrix}
\end{aligned}
\]

Можно сразу же заметить, что в первой матрице очень мало единиц, а во второй
их очень много. Это одно из свойств, которые использовал Хильтген для
доказательства того, что одно отображение вычислить намного проще другого.
Хильтген использовал деревья определённого вида, которые называются $(n - 1,
s)$-звёздами.

\begin{figure}[h]
\centering
\begin{tabular}{c c c}
  \begin{tikzpicture}[auto, node distance=1cm, every loop/.style={},
                      thick,main node/.style={circle,draw,font=\sffamily\normalsize\bfseries}]
  
    \node[main node] (1) [fill=black!15]                  {$x_1$};
    \node[main node] (2) [above left of=1] {};
    \node[main node] (3) [left of=2]       {};
    \node[main node] (4) [right of=1]      {};
    \node[main node] (5) [below left of=1] {};
    \node[main node] (6) [left of=5]      {};
  
    \path[every node/.style={font=\sffamily\normalsize\bfseries}]
      (1) edge [above right] node {} (2)
          edge [above] node {} (4)
          edge [above left] node {} (5);
  
    \path[every node/.style={font=\sffamily\normalsize\bfseries}]
      (2) edge [above] node {} (3);
  
    \path[every node/.style={font=\sffamily\normalsize\bfseries}]
      (5) edge [above] node {} (6);
  
  \end{tikzpicture}
& \hspace{1cm} &
  \begin{tikzpicture}[auto, node distance=1cm, every loop/.style={},
                      thick,main node/.style={circle,draw,font=\sffamily\normalsize\bfseries}]
  
    \node[main node] (1) [fill=black!15]     {$x_1$};
    \node[main node] (2) [above left of=1]   {};
    \node[main node] (6) [above left of=2]   {};
    \node[main node] (3) [above right of=1]  {};
    \node[main node] (7) [above right of=3]  {};
    \node[main node] (4) [below left of=1]   {};
    \node[main node] (8) [below left of=4]   {};
    \node[main node] (5) [below right of=1]  {};
    \node[main node] (9) [below right of=5]  {};
  
    \path[every node/.style={font=\sffamily\normalsize\bfseries}]
      (1) edge [above] node {} (2)
          edge [above] node {} (3)
          edge [above] node {} (4)
          edge [above] node {} (5);

    \path[every node/.style={font=\sffamily\normalsize\bfseries}]
      (2) edge [above] node {} (6);

    \path[every node/.style={font=\sffamily\normalsize\bfseries}]
      (3) edge [above] node {} (7);

    \path[every node/.style={font=\sffamily\normalsize\bfseries}]
      (4) edge [above] node {} (8);

    \path[every node/.style={font=\sffamily\normalsize\bfseries}]
      (5) edge [above] node {} (9);

  \end{tikzpicture}
\end{tabular}

\caption{Примеры $(5, 3)$- и $(8, 4)$-звёзд}
\label{fig_stars}
\end{figure}

$(n-1, s)$-звездой назовём дерево с $n-1$ рёбрами, вершины которого делятся на:
\begin{itemize}
\item один центр "--- вершину со степенью $\geq 2$, которая помечена $x_1$;
\item ровно $s$ листьев "--- вершин степени $1$, каждый из которых находится на
расстоянии $\ceil{\frac {n-1} s}$ или $\floor{\frac {n-1} s}$ от центра;
\item остальные вешины степени $2$.
\end{itemize}

Примеры нескольких звёзд изображены на рисунке \ref{fig_stars}.

Если дерево является звездой, то выражение для $y_n$ через $x$ имеет очень
простой вид. Чтобы получить его, рассмотрим сумму переменных во всех листьях
\begin{align*}
\sum_{i \text{ "--- лист}} x_i &= \sum_{i \text{ "--- лист}} \left( x_1 + \sum_{j \in P_i} y_j \right) \\
\shortintertext{обозначим $e_s = s \mod 2$}
&= e_s \cdot x_1 + \sum_{i \text{ "--- лист}} \sum_{j \in P_i} y_j \\
&= e_s \cdot x_1 + \sum_{i=1}^{n-1} y_j
= e_s \cdot \sum_{i=1}^n y_i + \sum_{i=1}^{n-1} y_j \\
&= e_s \cdot y_n + (1 + e_s)\sum_{i=1}^{n-1} y_j. \\
\end{align*}
Рассмотрев случаи чётного и нечётного $s$, получаем выражение для $y_n$:
\[
y_n = \begin{cases}
\displaystyle \sum_{i \text{ "--- лист}} x_i, & \text{если $s$ нечётно} \\
\displaystyle x_1 + \sum_{i \text{ "--- лист}} x_i, & \text{если $s$ чётно}.
\end{cases}
\]

Обозначим символом $\lambda_{n, s}(x) = y$ биекцию, которая отображает биты $x$
в биты $y$ тем способом, который задаёт $(n - 1, s)$-звезда. А матрицу $n \times
n$, определяющую линейное преобразование $\lambda_{n, s}$ обозначим как
$\Lambda_{n, s}$. То есть $\lambda_{n, s} = (x \mapsto \Lambda_{n, s} x)$.

Хильтген доказал \cite{hiltgen1993, hiltgen1994} следующую теорему о сложности
$\lambda_{n, s}$ и обратной к ней функции.

\begin{theorem}[Хильтген]
\label{thm_hiltgen}
\[
\begin{aligned}
&C(\lambda_{n, s}) = n + s + e_s - 2 & \text{и} & &C(\lambda_{n, s}^{-1}) = \floor*{\frac {2s - 1} s (n - 1)}.
\end{aligned}
\]
\end{theorem}

Из этого сразу же следует, что $\lambda_{n, s}$ является односторонней функцией
в слабом смысле:
\begin{itemize}
\item порядка $3/2$ при $s = 2$;
\item порядка $2$ при $s = \sqrt{n}$.
\end{itemize}

\subsection{Трудный бит}

Наметим план того, как будем строить трудный бит для $\lambda_{n, s}$.
Напомним, что эта перестановка принимает $n$ битов "--- $\lambda_{n, s} : \F^n
\to \F^n$. Давайте теперь дополним её ещё $n$ лишними входными битами, получив
перестановку:
\[
\begin{aligned}
&f_{n, s} : \F^n \times \F^n \to \F^n \times \F^n
&
\text{вида}&
&
f_{n, s}(x, y) = (x, \lambda_{n, s}(y)).&
\end{aligned}
\]
Как раз для этой функции мы будем строить трудный бит.

Трудный бит будет скалярным произведением
\[
\begin{aligned}
&h_n : \F^n \times \F^n \to \F
&
\text{вида}&
&
h_n(x, y) = x^\top y.&
\end{aligned}
\]

Для того, чтобы доказать надёжность в слабом смысле для такой конструкции, нужно
оценить сложность функций $f_{n ,s}$, $h_n$ и $h_n \circ f_{n, s}^{-1}$. Для
первых двух оценки тривиальны:
\begin{itemize}
\item $C(f_{n, s}) = C(\lambda_{n, s}) = n + s + e_s - 2$, так как оптимальная
схема для $f_{n, s}$ никак не пользуется своим входом $x$ и в точности равна
оптимальной схеме для $\lambda_{n, s}$;
\item $C(h_n) = 2n - 1$ "--- трудный бит можно реализовать как $\sum x_i y_i$ за
${2n - 1}$ гейтов, а за меньшее число гейтов нельзя "--- функция зависит от всех
своих $2n$ входных битов.
\end{itemize}

Нижняя оценка для функции $h_n \circ f_{n, s}^{-1}$ является предметом следующей
секции. Но прежде, чем перейти к ней, сделаем несколько наблюдений об этой
функции.

По определению $\lambda_{n, s}$ и $f_{n, s}$ получаем, что
\[
(h_n \circ f_{n, s}^{-1})(x, y) = h_n(x, \Lambda_{n, s}^{-1}y) = x^\top \Lambda_{n, s}^{-1} y,
\]
то есть эта функция является билинейной формой.

Поймем, как выглядит матрица $\Lambda_{n, s}^{-1}$. Для этого введём матрицы
$D_k$ и $A_L$ и выразим её через них.

Пусть $D_l$ это квадратная матрица $l \times l$, у которой на главной диагонали и
ниже неё стоят нули, а на всех остальных позициях "--- единицы.

\begin{definition}
Для последовательности $l_1 \dots l_k$ символом $A_{l_1, \dots l_k}$ обозначим
квадратную матрицу размера $(1 + \sum l_i) \times (1 + \sum l_i)$. В левом-верхнем
углу этой матрицы будет стоять единица. За ней вдоль главной диагонали будут идти
матрицы $D_{l_1}, D_{l_2} \dots D_{l_k}$ (как в блочно-диагональной матрице) до
правого нижнего угла. На всех остальных позициях, не занятых матрицами $D_{l_i}$
и левой верхней единицей, будут стоять единицы.
\end{definition}

Для удобства записи, мы будем иногда обозначать последовательность из нижнего
индекса $A_L$ вектором $L = (l_1 \dots l_k)$.

\begin{remark}
Строки и столбцы матрицы $A_L$ можно переставить таким образом, чтобы она
оказалась симметричной относительно главной диагонали.
\end{remark}

К примеру, $A_{1, 2, 3}$ будет выглядеть как
\[
\begin{bmatrix}
1 & 1 & 1 & 1 & 1 & 1 & 1 \\
1 & \mathbf{0} & 1 & 1 & 1 & 1 & 1 \\
1 & 1 & \mathbf{0} & \mathbf{1} & 1 & 1 & 1 \\
1 & 1 & \mathbf{0} & \mathbf{0} & 1 & 1 & 1 \\
1 & 1 & 1 & 1 & \mathbf{0} & \mathbf{1} & \mathbf{1} \\
1 & 1 & 1 & 1 & \mathbf{0} & \mathbf{0} & \mathbf{1} \\
1 & 1 & 1 & 1 & \mathbf{0} & \mathbf{0} & \mathbf{0} \\
\end{bmatrix},
\]
где жирным выделены подматрицы $D_1$, $D_2$, $D_3$.

Именно вид такой матрицы $A_L$ имеет интересующая нас $\Lambda_{n, s}^{-1}$. А
именно:

\begin{remark}
Матрица $A_{l_1 \dots l_k}$ задаёт такое же линейное преобразование, как и
преобразование, задаваемое деревом (описанным в начале этой секции образом),
состоящим из $k$ путей с длинами $l_1 \dots l_k$, от одного конца каждого из
которых ведут рёбра в вершину-центр $x_1$. Подматрицы $D_{l_i}$ в этом случае
соответствуют этим самым путям.
\end{remark}

\begin{figure}[h]
\centering
\begin{tikzpicture}[auto, node distance=2cm, every loop/.style={},
                    thick,main node/.style={circle,draw,font=\sffamily\normalsize\bfseries}]

  \node[main node] (1) [fill=black!15]   {$x_1$};
  \node[main node] (2) [below left of=1] {$x_2$};
  \node[main node] (3) [above left of=1] {$x_3$};
  \node[main node] (4) [left of=3]       {$x_4$};
  \node[main node] (5) [right of=1]      {$x_5$};
  \node[main node] (6) [right of=5]      {$x_6$};
  \node[main node] (7) [right of=6]      {$x_7$};

  \path[every node/.style={font=\sffamily\normalsize\bfseries}]
    (1) edge [above left] node {$y_1$} (2)
    (1) edge [above right] node {$y_2$} (3)
    (1) edge [above] node {$y_4$} (5);

  \path[every node/.style={font=\sffamily\normalsize\bfseries}]
    (3) edge [above] node {$y_3$} (4);

  \path[every node/.style={font=\sffamily\normalsize\bfseries}]
    (6) edge [above] node {$y_5$} (5)
    (6) edge [above] node {$y_6$} (7);

\end{tikzpicture}
\caption{Дерево, соответствующее $A_{1, 2, 3}$}
\label{fig_last_tree}
\end{figure}

Поэтому $A_L = \Lambda_{n, s}$ (с точностью до порядка столбцов), если $k = s$,
$n = 1 + \sum l_i$ и компонеты вектора $L$ отличаются друг от друга максимум на
единицу: $l_i \in \{\ceil{\frac {n-1} s}, \floor{\frac {n-1} s}\}$.

К примеру, соответствующее упомянутой выше матрице $A_{1,2,3}$ дерево изображено
на рисунке \ref{fig_last_tree}.

В следующей секции доказывается нижняя оценка на сложность вычисления билинейной
формы $(x, y) \mapsto x^\top A_L y$, она же будет применима и для функции $h_n
\circ f_{n, s}^{-1}$.

\section{Нижняя оценка}
\label{sec_bound}

В следующей лемме используются такие обозначения:
\begin{itemize}
\item $\rowm_i(M)$ "--- функция, удаляющая $i$-тую строку из матрицы $M$;
\item $\colm_j(M)$ "--- функция, удаляющая $j$-тый столбец из матрицы $M$;
\item $e_i$ "--- вектор, имеющий единицу на позиции $i$ и нули на всех остальных.
\end{itemize}

\begin{lemma} \label{easy}
Для любой строки $i$ (столбца) матрицы $A_L$ существует такой столбец $j$
(строка), что удаление этих строки и столбца из $A_L$ даст $A_{L - e_r}$ "---
другими словами, уменьшит на единицу одну из компонент $l_r$ вектора $L$:
\[
(\rowm_i \circ \colm_j)(A_L) = A_{L - e_r}.
\]

При этом, если после уменьшения компоненты $l_r$ на единицу она стала равна нулю,
то будем считать, что она совсем удаляется из вектора $L$.
\end{lemma}
\begin{proof}
Если $i = 1$ и была удалена первая строка, состоящая из всех единиц, тогда
установим $j := 2$ и удалим второй столбец. После этого появится новая состоящая
из единиц строка, и $l_1$ уменьшится на единицу.

Если $i > 1$ и была удалена строка, пересекающая какую-то из подматриц $D_r$,
тогда установим $j := i$ и удалим симметричный столбец. Легко проверить, что
\[
(\rowm_{i'} \circ \colm_{i'})(D_l) = D_{l-1}
\]
для любого $i' \leq l$.
\end{proof}

Доказательство нижней оценки, которое будет приведено в теореме
\ref{main}, пользуется техникой \begin{foreignlanguage}{english}gate
elimination\end{foreignlanguage} "--- мы фиксируем какие-то из входов функции
и для полученной функции применяем индукционное предположение. Но при
фиксировании каких-то входных битов квадратичной формы $(x, y) \mapsto x^\top A_L
y$ полученная функция может уже не быть квадратичной формой. Она будет иметь
вид $(x, y) \mapsto x^\top A_L y + u^\top x + v^\top y$ для каких-то векторов
$u$ и $v$. Поэтому оценка будет доказываться на функцию именно такого вида, и
некоторые вспомогательные утверждения ниже будут касаться функций такого вида.

\begin{lemma} \label{tough}
Для вектора $L$ обозначим $n = 1 + \sum l_i$.

Пусть $n \geq 2$, а функция
\[
g_n : \{0, 1\}^n \times \{0, 1\}^n \to \{0, 1\} \hspace{2.5cm}
g_n(x, y) = x^\top A_L y + u^\top x + v^\top y
\]
для некоторых $n$-мерных векторов $u$ и $v$. А $\xi : \{0, 1\}^2 \to \{0, 1\}$
"--- произвольная функция от двух битов, которая зависит от обоих своих входов.

Тогда никакая функция, корректно вычисляющая $g_n$ более чем на $7/8$ входов, не
является функцией от $\xi$ двух своих входных битов.
\end{lemma}

\begin{proof}
Для краткости будем опускать нижнии индекс и писать $g$ вместо $g_n$.

Пусть функция $g'(x, y)$ корректно вычисляет $g(x, y)$ на более, чем $7/8$ доле
всех $\{0, 1\}^{2n}$ входов. Обозначим элементы матрицы $A_L$ как $\{a_{i,
j}\}_{(i, j) \in {[n]^2}}$.

Рассмотрим два любых входных бита функции $g(x, y)$. Рассмотрим несколько
возможных случаев того, каким из входных векторов $x$ и $y$ функции $g$ они
принадлежат.
\begin{description}
\item{Биты "--- это $x_i$ и $x_j$.} У строк $i$ и $j$ матрицы $A_L$ обязательно
найдётся позиция (столбец), в которой они отличаются. Обозначим номер такого
столбца как $\delta$, а соответствующую столбцу переменную "--- как $y_\delta$.
Не теряя общности, будем считать, что в позиции $\delta$ строка $i$ имеет ноль,
а строка $j$ "--- единицу: $a_{i, \delta} = 0$ и $a_{j, \delta} = 1$.

Ясно, что найдётся какая-то подстановка $\rho$, которая фиксирует все входные
переменные $g$, кроме $x_i, x_j, y_\delta$ так, что при этом $g' \rvert _ \rho$
корректно вычисляет $g \rvert _ \rho$ на более чем $7/8$ доле входов $\{0,
1\}^3$. Покажем, что $g' \rvert _ \rho$ не может быть функцией от $\xi$ двух своих
входных битов.

Поймём, какой вид будет иметь $g \rvert _ \rho$. 
\[
g(x, y) = \sum_{i', j'} a_{i', j'} x_{i'} y_{j'} + \sum_{i'} u_{i'} x_{i'} + \sum_{j'} v_{j'} y_{j'}.
\]
Если зафиксировать $\rho$, то получится (помним, что $a_{i, \delta} = 0, a_{j, \delta} = 1$)
\[
g \rvert _ \rho (x_i, x_j, y_\delta) = x_j y_\delta + x_i b_i + x_j b_j + y_\delta c_\delta + d,
\]
где $b_i, b_j, c_\delta$ и $d$ "--- это константы, которые получаются от
фиксирования входов $g$.

Такая функция не является функцией от $\xi(x_i, x_j)$, поэтому она не может
вычислять $g \rvert _ \rho$ коррекно на $> 7/8$ входов, так как у этой функции
всего $2^3 = 8$ входов.

% Но убедимся в этом по-честному.
% Не теряя общности, можно считать, что константа $d = 0$.

\item{Биты "--- это $y_i$ и $y_j$.} Этот случай симметричен предыдущему.
\item{Биты "--- это $x_i$ и $y_j$.} Так как $A_L$ имеет одну строку и один
столбец, полностью состоящие из единиц, либо в строке $i$, либо в столбце $j$
найдётся единица на позиции, отличной от $(i, j)$. Не теряя общности будем
считать, что такая единица нашлась в столбце $j$ и расположена в клетке $(i',
j)$.

Аналогично предыдущему пункту выберем такую подстановку $\rho$ всех переменных,
кроме $x_i, x_{i'}, y_j$, чтобы $g \rvert _ \rho$ и $g' \rvert _ \rho$ совпадали
не менее, чем на $7/8$ входов.

Обозначив для краткости $a := a_{i, j}$, получим следующее выражение для $g
\rvert _ \rho$.
\[
g \rvert _ \rho (x_i, x_{i'}, y_j) = a x_i y_j + x_{i'} y_j + x_i b_i + x_{i'} b_{i'} + y_j c_j + d,
\]
где $b_{i}, b_{i'}, c_j$ и $d$ "--- константы.

Видно, что такая функция не является функцией от $\xi(x_i, y_j)$, поэтому она не
может вычислять $g \rvert _ \rho$ коррекно на $> 7/8$ входов, так как у этой
функции всего $2^3 = 8$ входов.
\end{description}
\end{proof}

\begin{lemma} \label{single_one}
Пусть $A$ "--- произвольная матрица, которая имеет единицу в клетке $(i, j)$, а
$u$ и $v$ "--- произвольные вектора.

Тогда любая функция, вычисляющая $g(x, y) = x^\top A y + u^\top x + v^\top y$ на
$> 3/4$ доле входов, обязана зависеть от $x_i$ и от $y_j$.
\end{lemma}
\begin{proof}
Докажем, что $g$ обязана зависеть от $x_i$, а для $y_i$ доказательство будет
симметричным.

Пусть $g'(x, y)$ вычисляет $g(x, y)$ на $> 3/4$ доле входов. Ясно, что можно
зафиксировать все входные переменные этих функций, кроме $x_i$ и $y_j$, таким
образом, чтобы после фиксирования эти функции по-прежнему совпадали на $> 3/4$
доле входов. Обозначим такую подстановку как $\rho$.

Так как у функции $g \rvert _ \rho$ два входных бита: $x_i$ и $y_j$, которые
могут принимать всего $4$ значения, любая $g' \rvert _ \rho$, вычисляющая
её на $> 3/4$ доле входов обязана вычислять её коррекно на всех входах. Заметим,
что функция $g \rvert _ \rho(x_i, y_j)$ является многочленом с коэффициентом $1$
при $x_i y_j$:
\[
\begin{aligned}
&g \rvert _ \rho (x_i, y_j) = x_i y_j + a x_i + b y_j + c,
&
\text{где $a, b, c \in \{0, 1\}$.}&
\end{aligned}
\]
По этому выражению ясно, что никакая функция $g' \rvert _ \rho$, не зависящая от
$x_i$, не может вычислить $g \rvert _ \rho$ корректно на всех входах.

Значит, не существует не зависящей от $x_i$ функции $g'$, которая вычисляла бы
$g$ верно на $> 3/4$ доле входов.
\end{proof}

\begin{theorem} \label{main}
При $n = 1 + \sum l_i \geq 2$ для любых $u, v \in \{0, 1\}^n$ функция
\[
g_n(x, y) = x^\top A_L y + u^\top x + v^\top y
\]
не может быть вычислена на более чем $7/8$ входов схемой размера менее $3n -
\max \{l_i\} - 5$. То же самое другими словами:
\[
C_{7/8}(g_n) \geq 3n - \max \{l_i\} - 5.
\]
\end{theorem}
\begin{proof}
Индукция по $n$.

\emph{База $n = 2$}. Очевидно, $C_{7/8}(g_n) \geq 0$.

\emph{Переход $n > 2$.} Рассмотрим любую функцию $g'_n$, которая корректно
вычисляет $g_n$ на более чем $7/8$ доле входов. Достаточно доказать, что
$C(g_n') \geq 3n - \max \{l_i\} - 5$.

Рассмотрим схему минимального размера для $g'_n$. Обозначим первый гейт этой
схемы в порядке топологической сортировки как $\xi$. На вход $\xi$ подаются
два входа схемы. По лемме \ref{tough} один из этих входов должен подаваться на
какой-то ещё гейт схемы. Зафиксируем этот вход схемы $z_1$ в значение $b_1$,
удалив из схемы два гейта. Если $g'_n$ вычисляла $g_n$ на $> 7/8$ доле входов,
то можно выбрать $b_1$ так, чтобы $g'_n \rvert_{z_1 = b_1}$ вычисляла $g_n
\rvert_{z_1 = b_1}$ на $ > 7/8$ доле входов.

Такое фиксирование удалит либо одну строку, либо столбец из матрицы $A_L$. Не
теряя общности, будем считать, что была удалена строка. Обозначим её номер как
$i$. По лемме \ref{easy} найдётся столбец $j$, такой что после удаления
строки $i$ и столбца $j$ из матрицы $A_L$ получится $A_{L'}$, где $L' = L - e_r$
для некоторого $r$.

Для удаления столбца $j$ из матрицы, полученной после фиксирования $z_1$,
зафиксируем соответствующий ему входной бит. Обозначим этот бит как $z_2$, а
значение, в которое его зафиксируем, как $b_2$. Значение $b_2$ можно выбрать
таким образом, чтобы $g'_n \rvert _ {z_1 = b_1, z_2 = b_2}$ верно вычисляла
$g_n \rvert _ {z_1 = b_1, z_2 = b_2}$ на $> 7/8$ входов.

Напомним, что $L = (l_1, \dots l_k)$. Рассмотрим два случая.
\begin{itemize}
\item Если $k \geq 2$, то после удаления строки $i$ в каждом столбце останется
как минимум одна единица. Поэтому из леммы \ref{single_one} следует, что
$g_n' \rvert _ {z_1 = b_1}$ зависит от $z_2$. А это значит, что при фиксировании
$z_2 = b_2$ из схемы удалится как минимум один гейт. В этом случае, мы удалили
три гейта из схемы, поэтому $C(g_n' \rvert _ {z_1 = b_1, z_2 = b_2}) \leq C(g_n') - 3$
и уменьшили одно из значений $l_i$ на единицу. По индукционному предположению
\[
\begin{aligned}
C(g_n' \rvert _ {z_1 = b_1, z_2 = b_2}) &\geq 3(n - 1) - \underbrace{\max \{l_i'\}}_{\leq \max \{l_i\}} - 5 \\
&\geq 3(n - 1) - \max \{l_i\} - 5.
\end{aligned}
\]
Отсюда получаем требуемое утверждение:
\[
\begin{aligned}
C(g_n') &\geq C(g_n' \rvert _ {z_1 = b_1, z_2 = b_2}) + 3 \\
        &\geq 3n - \max \{l_i\} - 5.
\end{aligned}
\]

\item Если $k = 1$. В этом случае после фиксирования $z_2 = b_2$ из схемы могло
ничего и не удалиться. Но всё равно мы удалили из схемы как минимум два гейта
фиксированием $z_1 = b_1$. Поэтому аналогично предыдущему пункту верно $C(g_n'
\rvert _ {z_1 = b_1, z_2 = b_2}) \leq C(g_n') - 2$, к тому же по индукционному
предположению
\[
\begin{aligned}
C(g_n' \rvert _ {z_1 = b_1, z_2 = b_2}) &\geq 3(n - 1) - \underbrace{\max \{l_i'\}}_{\max \{l_i\} - 1} - 5 \\
&= 3(n - 1) - \max \{l_i\} + 1 - 5.
\end{aligned}
\]
Получаем требуемое утверждение:
\[
\begin{aligned}
C(g_n') &\geq C(g_n' \rvert _ {z_1 = b_1, z_2 = b_2}) + 2 \\
        &\geq 3n - \max \{l_i\} - 5.
\end{aligned}
\]
\end{itemize}

Разобрав два случая выше, мы доказали, что $C(g_n') \geq 3n - \max \{l_i\} - 5$.
А так как это верно для всех функций $g_n'$, совпадающих с $g_n$ на $>7/8$ доле
входов, будет верно $C_{7/8}(g_n) \geq 3n - \max \{l_i\} - 5$.
\end{proof}

\section{Следствия и конструкции}
\label{sec_corr}

Обозначим задачу противника из секции \ref{sec_hiltgen} как $g_{n, s} = h_n
\circ f_{n, s}^{-1}$. Для неё верно следующее следствие из теоремы \ref{main}.

\begin{corollary}
\[
C_{7/8}(g_{n, s}) \geq 3n - \ceil*{\frac {n - 1} s} - 5.
\]
\label{corr_main}
\end{corollary}

% Рисунок \ref{fig_big_picture} иллюстриует общую картину всех рассмотренных в
% этой работе и работах Хильтгена оценок сложности функций. Все оценки, кроме $C$
% 
% \begin{figure}[h]
% \[
% \begin{tikzcd}
% x \arrow[rr, bend left, "n + s + e_s - 2" above] \arrow[rdd, bend right, "2n - 1" below left]
% & ~ &
% f_{n, s}(x)
%   \arrow[ldd, bend left, dashrightarrow, "\geq 3n - \ceil*{\frac {n - 1} s} - 5"]
%   \arrow[ll, bend left, dashrightarrow, "\floor*{\frac {2s - 1} s (n - 1)}" below] \\
% ~ &  ~   & ~ \\
% ~ & h_n(x) & ~
% \end{tikzcd}
% \]
% \caption{Схема всех оценок сложности, рассмотренных в этой работе}
% \label{fig_big_picture}
% \end{figure}

Теперь, выбирая конкретные значения для $s$, построим несколько односторонних
функций с трудным битом (в слабом смысле). Будем пользоваться для этого теоремой
\ref{thm_hiltgen} и предыдущим следствием \ref{corr_main}. Помним, что $C(h_n) =
2n - 1$ и не зависит от $s$.

\begin{construction}[$s = 2$.]
В этом случае получается односторонняя функция порядка $3/2$ из работы
\cite{hiltgen1993} и трудный бит для неё порядка $(3 - 1/2) / 2 = (1 + 1/4)$ с
вероятностью $7/8$.
\[
\begin{aligned}
C(f_{n, s}) &\leq n + 1 \\
C(f_{n, s}^{-1}) &\geq \frac 3 2 (n - 1) \\
C_{7/8}(g_{n, s}) &\geq (3 - \frac 1 2)n - 6. \\
\end{aligned}
\]
\end{construction}

\begin{construction}[$s = n - 1$.]
Это крайний случай. Здесь получается, что $f_{n, s}$ так же легко обратить, как
и вычислить, но оценка на $C_{7/8}(g_n)$ получается самая лучшая:
\[
\begin{aligned}
C(f_{n, s}) &\leq 2n - 2 \\
C(f_{n, s}^{-1}) &\geq 2n - 3 \\
C_{7/8}(g_{n, s}) &\geq 3n - 6. \\
\end{aligned}
\]
$f_{n,s}$ "--- односторонняя функция порядка $1$, а $h_{n}$ "--- трудный бит для
неё порядка $1 + 1/2$ с вероятностью $7/8$.
\end{construction}

Хильтген заметил \cite{hiltgen1993,hiltgen1994}, что при $s = o(n)$ и $s =
\omega(1)$ функция $\lambda_{n,s}$ является односторонней порядка $2$. В этом
легко убедиться, воспользовавшись теоремой \ref{thm_hiltgen}. Оказывается,
похожий трюк можно применить и для трудного бита, построенного в этой работе.
Это демонстрируется следующей конструкцией, которая выбирает $s = \sqrt n =
o(n)$.

\begin{construction}[$s = \sqrt{n}$.]
В этом случае получаются асимптотически наилучшие соотношения между сложностями
функций:
\[
\begin{aligned}
C(f_{n, s}) &\leq n + \sqrt{n} - 1 \\
C(f_{n, s}^{-1}) &\geq 2n - \sqrt n - 3 \\
C_{7/8}(g_{n, s}) &\geq 3n - \sqrt{n} - 6. \\
\end{aligned}
\]
Функция $f_{n, s}$ является односторонней порядка $2$, а $h_{n}$ является
трудным битом для неё поряка $1 + 1/2$ с вероятностью $7/8$.
\end{construction}

\section*{Заключение}
\addcontentsline{toc}{section}{Заключение}
В этой дипломной работе было предложено определение надёжного в слабом смысле
трудного бита, и построено несколько таких конструкций, для которых доказана их
надёжность. Предложенное определение основано на аналогичном определении для
односторонних функций, предложенном Хильтгеном самой первой работе
\cite{hiltgen1993}, где рассматривалась надёжность в слабом смысле для
криптографических примитивов.

Приведённая в этой работе конструкция трудного бита основана на односторонних
перестановках из работы Хильтгена. Для получения односторонней перестановки,
имеющей трудный бит, (надёжных в слабом смысле) из одновторонней перестановки
Хильтгена используется техника, при помощи которой в классической криптографии
строится односторонняя перестановка с трудным битом (надёжных в классическом
определении) из любой односторнней перестановки \cite{goldreich_levin}.

Параметры полученных в этой работе конструкций таковы: для односторонней
перестановки порядка $3/2$ получен трудный бит порядка $5/4$ с вероятностью
$7/8$; для односторонней перестановки порядка $2$ получен трудный бит порядка
$3/2$. Для доказательства надёжности обеих конструкций доказывается нижняя
оценка на вычисление некоторой билинейной формы в среднем.

\bibliography{main}{}
\bibliographystyle{plain}

\end{document}
