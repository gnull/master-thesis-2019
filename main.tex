\documentclass[oneside, a4paper]{article}

\usepackage[T1,T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{url, hyperref}
\usepackage[shortlabels]{enumitem}
\usepackage{amssymb,amsthm,amsmath,mathtools}
\usepackage{listings}

\usepackage{savesym}

\savesymbol{C}
\savesymbol{G}
\usepackage{complexity}
\restoresymbol{TXF}{C}
\restoresymbol{TXF}{G}

\usepackage{tikz-cd}

\usepackage{tocbibind}

\usepackage{thmtools}
\usepackage{thm-restate}

\usepackage{geometry}

% \geometry{
%    a4paper,
%    left=20mm,
%    right=20mm,
%  }

\newtheorem{theorem}{Теорема}
\newtheorem{exercise}{Упражнение}
\newtheorem{corollary}{Следствие}
\newtheorem{proposition}{Предложение}
\newtheorem{lemma}{Лемма}
\theoremstyle{definition}
\newtheorem{definition}{Определение}
\theoremstyle{remark}
\newtheorem{remark}{Замечание}

% \renewcommand{\thesection}{}
% \renewcommand{\thesubsection}{}

\newcommand\rowm{\ensuremath{\operatorname{row}^-}}
\newcommand\colm{\ensuremath{\operatorname{col}^-}}
\newcommand\F{\ensuremath{\mathbb F}}

\DeclareMathOperator{\lcm}{LCM}
\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\val}{val}

\DeclarePairedDelimiter\abs{\lvert}{\rvert}
\DeclarePairedDelimiter\ang{\langle}{\rangle}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}
\DeclarePairedDelimiter\ceil{\lceil}{\rceil}

\DeclareRobustCommand{\divby}{%
  \mathrel{\vbox{\baselineskip.65ex\lineskiplimit0pt\hbox{.}\hbox{.}\hbox{.}}}%
}

\begin{document}

\title{Слабо надёжные трудные биты \\ \large Дипломная работа}
\author{\normalsize Выполнил: Олейников Иван \\ \normalsize Научный руководитель: Гирш Эдуард Алексеевич}
\date{\today}
\maketitle

\abstract{В этой дипломной работе предлагается определение слабо надёжного
трудного бита. Неформально говоря, слабо надёжным трудным битом для биективной
булевой функции $f$ здесь называется такая функция $h$, что вычислить $h(x)$ по
заданному $f(x)$ (то есть вычислить $h \circ f^{-1}$) как минимум в константу
раз труднее, чем вычислить $f(x)$ или $h(x)$ по заданному $x$. Под трудностью
функции здесь понимается размер минимальной вычисляющей её схемы из произвольных
гейтов арности $2$.

Кроме того, в этой работе приводятся конструкции трудных битов для нескольки
линейных функций, основанных на слабо надёжных односторонних функциях,
построенных в прежних работах Хильтгена \cite{hiltgen1993}.

Слабо надёжная одностороннаяя функция "--- это такая функция, обратить которую
на определённой доле входов как минимум в константу раз труднее, чем вычислить
её значение в точке.}

\tableofcontents

\section{Введение}

В современной криптографии существуют определения надёжности для
многих криптографических примитивов, таких как односторонние функции,
односторонние функции с секретом, трудные биты, протоколы привязки
\begin{foreignlanguage}{english}(bit commitment)\end{foreignlanguage},
шифрование с публичным и секретным ключом. И эти определения очень сильные "---
они предъявляют очень строгие требования к надёжности примитивов. Требования
настолько сильные, что неизвестно ни одной конструкции таких примитивов,
надёжность которой была бы доказана безусловно.

Действительно, ведь если доказать существование, скажем, односторонних функций,
то это приведёт к решению некоторых вопросов теории сложности, которые уже очень
давно остаются открытыми. К примеру, это будет значить, что $\NP \nsubseteq
\BPP$ и, следовательно, $\P \neq \NP$ \cite{goldreich}. Поэтому надежды на то,
что для какой-то функции будет доказано, что она является одностронней, мало,
и все известные утверждения о надёжности односторонних функций доказываются
условно, исходя из некоторых популярных предположений.

Одним из способов справиться с описанной проблемой неизбежности предположений
при доказательствах надёжности примитивов являются полные конструкции
криптографических примитивов.

Известны конструкции полных односторонних функций \cite{complete_owf,
complete_owf2} и полных криптосистем с публичным ключом \cite{complete_pkcs,
complete_pkcs2}. Их надёжность доказывается исходя из самых слабых возможных
предположений. А именно, из предположения о том, что односторонние функции (или
криптосистемы с публичным ключом) вообще существуют. Ведь если это предположение
неверно, то односторонних функций (или криптосистем с публичным ключом) совсем
не существует и никакие предположения не помогут их построить. Но применимость
таких конструкций на практике ограничена, так как для них не известно
конкретных оценок на то, как трудно их взломать для заданных значениях парамера
безопасности (к примеру, длины ключа). А именно такие оценки нужны для того,
чтобы оценить надёжность примитива при его практическом применении.

В своих работах \cite{hiltgen1993,hiltgen1994} Хильтген предложил подойти с
другой стороны к описанной проблеме неизбежности предположений в доказательствах
надёжности. Он предложил поискать другие, более слабые определения надёжности.
Во-первых, чтобы понять, насколько слабыми можно сделать определения надёжности,
чтобы они при этом оставались полезными для практических применений. Во-вторых,
чтобы понять, насколько сильные гарантии надёжности удастся доказать. Основное
внимание его работы было сосредоточено на односторонних функциях.

Хильтген предложил два новых определения надёжности для односторонних функций:
\emph{слабую надёжность порядка $k$} (\begin{foreignlanguage}{english}feeble
one-wayness of order $k$\end{foreignlanguage}) и \emph{практическую надёжность
порядка $k$} (\begin{foreignlanguage}{english}practical one-wayness of order
$k$\end{foreignlanguage}).

В этой дипломной работе будет идти речь об односторонних функциях и трудных
битах для них. Поэтому рассмотрим для примера представленное ниже определение
односторонней функции из книги \cite[гл. 2]{goldreich}.

\begin{definition}
Функция $f : \{0, 1\}^n \to \{0, 1\}^{l(n)}$ называется (сильно) односторонней,
если
\begin{enumerate}[(a)]
\item $f$ вычислима полиномиальным по времени алгоритмом;
\item но для любого семейства схем $\{ C_n \}_{n \in \mathbb N}$ полиномиального
от $n$ размера и любого полинома $p(n)$ при достаточно больших $n$ выполняется:
\[
\Pr_{x \gets \{0, 1\}^n}[(f \circ C_n \circ f)(x) = f(x)] < \frac 1 {p(n)}.
\]
\end{enumerate}

Другими словами, вероятность того, что схема-противник $C_n$ сумеет по заданному
$f(x)$ найти какой-нибудь элемент $x'$, на котором $f(x') = f(x)$, должна
убывать быстрее любого обратного полинома $1 / p(n)$.

\emph{(Есть так же вариант определения <<равномерной>> односторонней функции, в
котором вместо семейства схем $\{C_n\}$ противником является полиномиальный по
времени вероятностный алгоритм $A$.)}
\end{definition}


С другими криптографическими примитивами положение дел схожее: их определения
требуют очень сильных свойств, поэтому безусловных доказательств надёжности
таких примитивов неизвестно. Учитывая это, исследователи пошли на компромис
с реальностью и стали пробовать доказывать надёжность криптографических
примитивов в предположении о том, что какие-то кажущиеся многим правдоподобными
предположения из теории сложности верны, и выделять наиболее правдоподобные и
слабые предположения, которые нужны для таких доказательств.

Левин построил полную одностороннюю функцию \cite{complete_owf, complete_owf2}. Так



















\section{Ko-ko-ko-ko!}






























\section{Введение}

В этой работе даётся определение слабо надёжного трудного бита, а также
строятся несколько таких конструкций. Определение содержится в этой секции,
кроме него в ней даётся высокоуровневый обзор того, о чём будут следующие
секции.

\begin{figure}[h]
\[
\shorthandoff{"}
\begin{tikzcd}
x \arrow[rr, "f"] \arrow[rd, "h"] & ~ & f(x) \arrow[ld, dashrightarrow, "h \circ f^{-1}"] \\
~ & h(x) & ~
\end{tikzcd}
\shorthandon{"}
\]
\caption{Схема отображений функции $f$ и её трудного бита $h$}
\end{figure}


Символом $C(f)$ обозначим размер минимальной схемы с гейтами из $\{0, 1\}^2 \to
\{0, 1\}$, вычисляющей функцию $f : \{0, 1\}^n \to \{0, 1\}^m$. А символом
$C_\alpha(f)$ обозначим размер, минимальной схемы, которая вычисляет $f$
корректно на \emph{большей} чем $\alpha$ доле всех входов $\{0, 1\}^n$.

\subsection{Мотивация и определения}

TODO: Добавить ссылки на \cite{hirsch_milanich_nikolenko} и ещё одну-две статьи
Николенко.

TODO: Уместить в нужные места эти определения:

\begin{definition}[Схемная сложность]
Булевой схемой называется ациклический ориентированный граф, вершины которого
бывают двух типов:
\begin{itemize}
\item Входы, имеющие входную степень $0$. Каждая такая вершина $v$ помечена
  переменной $x_v$ из набора $x_1$, $x_2$ \dots $x_n$.
\item Гейты, имеющие входную степень $2$. Каждая такая вершина $v$ помечена
  функцией $\phi_v : \{0, 1\}^2 \to \{0, 1\}$.
\end{itemize}

Если заданы значения переменных $\bar{x} = (x_1$ \dots $x_n)$, то каждый вход
схемы $v$ можно пометить значением соответствующей переменной "--- $\val_{\bar
x}(v) := x_v$. Затем индуктивно распространить эти значения от входов схемы по
всем гейтам схемы таким образом: если в гейт $w$ входят рёбра из вершин $u$ и
$v$, которые уже помечены значениями $\val_{\bar x}(u)$ и $\val_{\bar x}(v)$,
пометим $\val_{\bar x}(w) := f_w(\val_{\bar x}(u), \val_{\bar x}(v))$.

\end{definition}

\begin{definition}[Пренебрежимо малая функция]
Функция $s : \mathbb N \to \mathbb N$ называется пренебрежимо малой, если для
любого полинома $p(n)$ при достаточно больших $n$ значение $s(n)$ меньше $1 /
p(n)$:
\[
\exists N,\quad \forall n > N,\quad s(n) < \frac 1 {p(n)}.
\]
\end{definition}

Предлагаемое в этой работе определение слабо надёжного трудного бита основано
на существующем определении слабо надёжной односторонней функции. Поэтому для
начала вспомним её определение и его связь с определением обычных односторонних
функций из сложностной криптографии.

В сложностной криптографии существует определение односторонней функции, его
можно найти в книге Голдрейха \cite{goldreich}. Ниже приводится его неформальная
формулировка.

\begin{definition}[Из книги \cite{goldreich}]
Функция $f$ называется односторонней, если $f$ вычислима полиномиальным по
времени алгоритмом, но для любой схемы $A$, вероятность того, что $A$ корректно
обратит $f$ на входе длины $n$ "---
\[
\Pr_{x \gets \{0, 1\}^n}[(f \circ A \circ f)(x) = f(x)]
\]
должна убывать быстрее любого обратного полинома от $n$.
\end{definition}

Аналогично этому определению Хильтген \cite{hiltgen1993} предложил
следующее определение слабо надёжной односторонней перестановки порядка
$k$ (англ. \begin{foreignlanguage}{english}feebly-one-way of order
$k$\end{foreignlanguage}).

\begin{definition}[Хильтген \cite{hiltgen1993}]
Семейство перестановок $\{f_n\}$, где $f_n : \{0, 1\}^n \to \{0, 1\}^n$,
называется слабо односторонним порядка $k > 1$, если с ростом $n$ схемная
сложность $C(f_n^{-1})$ приближается к $k \cdot C(f_n)$:
\[
\begin{aligned}
&\lim_{l \to \infty} \sup_{n > l} C(f_n) = \infty
&
\text{и}&
&
\lim_{l \to \infty} \sup_{n > l} C(f_n^{-1}) / C(f_n) = k&
\end{aligned}
\]
\end{definition}

В этой дипломной работе предлагается определение слабой надёжности для другого
криптографического примитива из сложностной криптографии "--- трудного бита
односторонней перестановки.

Напомним, как определятся обычный трудный бит в сложностной криптографии.

\begin{definition}[Из книги \cite{goldreich}]
Предикат $h_n : \{0, 1\}^n \to \{0, 1\}$ называется трудным битом для
перестановки $f_n : \{0, 1\}^n \to \{0, 1\}^n$, если $h$ и $f$ вычислимы за
полиномиальное время, но никакая схема полниномиального размера $A$ не способна
эффективно вычислить $h(x)$ по заданному $f(x)$. То есть вероятность
\[
\Pr_{x \gets \{0, 1\}^n}[A(f_n(x)) = h_n(x)]
\]
убывает быстрее любого обратного полинома.
\end{definition}

Аналогично тому, как Хильтген получил определение слабо надёжной односторонней
функции из определения односторонней функции, предлагается следующее определение
для слабо надёжного трудного бита.

\begin{definition}[Слабо надёжный трудный бит]
Предикат $h_n : \{0, 1\}^n \to \{0, 1\}$ будем называть трудным битом порядка
$k$ с вероятностью $\alpha$ для перестановки $f_n : \{0, 1\}^n \to \{0, 1\}^n$ с
вероятностью $\alpha$ если
\[
\begin{aligned}
&\lim_{l \to \infty} \sup_{n > l} C(h_n) = \infty
&
\text{и}&
&
\lim_{l \to \infty} \sup_{n > l} \frac {C_\alpha(h_n \circ f_n^{-1})} {\max \{ C(h_n), C(f_n) \}} = k&
\end{aligned}
\]
\end{definition}

Интуинтивно такое определение можно понять так. Функция $h_n \circ f_n^{-1}$
здесь обозначает как раз задачу противника "--- по заданному $f_n(x)$ вычислить
$h_n(x)$. А функции $h_n$ и $f_n$ "--- это те задачи, которые решает
пользователь трудного бита; он может <<легко>> найти трудный бит $h_n(x)$ по
входу $x$, а также применить ко входу функцию $f_n$. И определение требует,
чтобы для решения задачи противника требовалось в $k$ раз больше операций, чем
для любой из этих двух решаемых пользователем задач. А точнее, мы требуем, чтобы
соотношение числа операций, совершаемых противником и пользователем,
приближалось к $k$ с ростом $n$.

\subsection{Обзор конструкций}

В этой дипломной работе приведены конструкции трудных битов порядка $(1
+ \frac 1 4)$ и $(1 + \frac 1 2)$ с вероятностью $7/8$. Эти конструкции
являются трудными битами для линейных односторонних функциях из работ Хильтгена
\cite{hiltgen1993} (с незначительными изменениями). Хильтген нашёл несколько
последовательностей квадратных обратимых матриц $\{M_n\}$ над $\F_2$, таких что
сложность умножения на такую матрицу имеет в $k$ раз меньшую схемную сложность,
чем сложность умножения на обратную к ней.

В этой работе мы будем рассматривать функции
\[
\begin{aligned}
&f_n : \F_2^n \times \F_2^n \to \F_2^n \times \F_2^n
&
\text{вида}&
&
f_n(x, y) = (x, M_n y).&
\end{aligned}
\]
В качестве семейства матриц
$\{M_n\}$ будут выбраны матрицы из работ Хильтгена, для которых уже доказаны
точные оценки на их схемную сложность и сложность обратных к ним. В качестве
трудного бита для $f_n$ мы рассмотрим внутреннее произведение \[
h_n(x, y) = x^\top y.
\]
В этом случае задача атакующего будет функцией $g_n = h_n \circ f_n^{-1}$:
\[
g_n(x, y) = x^\top M_n^{-1} y.
\]

Очевидная схема для вычисления $h_n$ будет оптимальной: $h_n(x, y) = \sum_i x_i
y_i$, для её реализации потребуется $n$ умножений и $n - 1$ сложений. Никакая
меньшая схема размера менее $2n - 1$ не сможет вычислить $h_n$ корректно, так
как $h_n$ имеет $2n$ входов и зависит от каждого из них. Поэтому $C(h_n) = 2n - 1$.

Сложность $f_n$ оценивается у Хильтгена, в конце этой работы мы просто
воспользуемся его результатами.

В следующих секциях мы определим семейства матриц $\{M_n^{-1}\}$ (вместе с ними
определятся и $M_n$, но начать нам удобнее с $M_n^{-1}$) и докажем нижнюю оценку
на сложность билинейных форм $g(x, y) = x^\top M_n^{-1} y$.

\section{Обозначения}

%% TODO
% Нужно написать о том, что я отождествляю {0, 1} и F₂

Символом $D_l$ обозначим квадратную матрицу $l \times l$, у которой на главной
диагонали и ниже неё стоят нули, а на всех остальных позициях "--- единицы.

\begin{definition}
Для последовательности $l_1 \dots l_k$ символом $A_{l_1, \dots l_k}$ обозначим
квадратную матрицу размера $(1 + \sum l_i) \times (1 + \sum l_i)$. В левом-верхнем
углу этой матрицы будет стоять единица. За ней вдоль главной диагонали будут идти
матрицы $D_{l_1}, D_{l_2} \dots D_{l_k}$ (как в блочно-диагональной матрице) до
правого нижнего угла. На всех остальных позициях, не занятых матрицами $D_{l_i}$
и левой верхней единицей, будут стоять единицы.
\end{definition}

Для удобства записи, мы будем иногда обозначать последовательность из нижнего
индекса $A_L$ вектором $L = (l_1 \dots l_k)$.

\begin{remark}
Строки и столбцы матрицы $A_L$ можно переставить таким образом, чтобы она
оказалась симметричной относительно главной диагонали.
\end{remark}

К примеру, $A_{1, 2, 3}$ будет выглядеть как
\[
\begin{bmatrix}
1 & 1 & 1 & 1 & 1 & 1 & 1 \\
1 & \mathbf{0} & 1 & 1 & 1 & 1 & 1 \\
1 & 1 & \mathbf{0} & \mathbf{1} & 1 & 1 & 1 \\
1 & 1 & \mathbf{0} & \mathbf{0} & 1 & 1 & 1 \\
1 & 1 & 1 & 1 & \mathbf{0} & \mathbf{1} & \mathbf{1} \\
1 & 1 & 1 & 1 & \mathbf{0} & \mathbf{0} & \mathbf{1} \\
1 & 1 & 1 & 1 & \mathbf{0} & \mathbf{0} & \mathbf{0} \\
\end{bmatrix},
\]
где жирным выделены подматрицы $D_1$, $D_2$, $D_3$.

Матрицы $A_L$ и будут использоваться в конструкциях в качестве $M_n^{-1}$, где
$n = 1 + \sum l_i$.

\section{Нижняя оценка}

В следующем утверждении используются такие обозначения:
\begin{itemize}
\item $\rowm_i(M)$ "--- функция, удаляющая $i$-тую строку из матрицы $M$;
\item $\colm_j(M)$ "--- аналогично, функция, удаляющая $j$-тый столбец из матрицы $M$;
\item $e_i$ "--- вектор, имеющий единицу на позиции $i$.
\end{itemize}

\begin{proposition} \label{easy}
Для любой строки $i$ (столбца) матрицы $A_L$ существует такой столбец $j$
(строка), что удаление этих строки и столбца из $A_L$ даст $A_{L - e_r}$ "---
другими словами, уменьшит на единицу одну из компонент $l_r$ вектора $L$:
\[
(\rowm_i \circ \colm_j)(A_L) = A_{L - e_r}.
\]

При этом, если после уменьшения компоненты $l_r$ на единицу она стала равна нулю,
то будем считать, что она совсем удаляется из вектора $L$.
\end{proposition}
\begin{proof}
Если $i = 1$ и была удалена первая строка, состоящая из всех единиц, тогда
установим $j := 2$ и удалим второй столбец. После этого появится новая состоящая
из единиц строка, и $l_1$ уменьшится на единицу.

Если $i > 1$ и была удалена строка, пересекающая какую-то из подматриц $D_r$,
тогда установим $j := i$ и удалим симметричный столбец. Легко проверить, что
\[
(\rowm_{i'} \circ \colm_{i'})(D_l) = D_{l-1}
\]
для любого $i' \leq l$.
\end{proof}

Доказательство нижней оценки, которое будет приведено в теореме
\ref{main}, пользуется техникой \begin{foreignlanguage}{english}gate
elimination\end{foreignlanguage} "--- мы фиксируем какие-то из входов функции
и для полученной функции применяем индукционное предположение. Но при
фиксировании каких-то входных бит квадратичной формы $(x, y) \mapsto x^\top A_L
y$ полученная функция может уже не быть квадратичной формой. Она будет иметь
вид $(x, y) \mapsto x^\top A_L y + u^\top x + v^\top y$ для каких-то векторов
$u$ и $v$. Поэтому оценка будет доказываться на функцию именно такого вида, и
некоторые вспомогательные утверждения ниже будут касаться функций такого вида.

\begin{proposition} \label{tough}
Для вектора $L$ обозначим $n = 1 + \sum l_i$.

Пусть $n \geq 2$, а функция
\[
g_n : \{0, 1\}^n \times \{0, 1\}^n \to \{0, 1\} \hspace{2.5cm}
g_n(x, y) = x^\top A_L y + u^\top x + v^\top y
\]
для некоторых $n$-мерных векторов $u$ и $v$. А $\xi : \{0, 1\}^2 \to \{0, 1\}$
"--- произвольная функция от двух бит, которая зависит от обоих своих входов.

Тогда никакая функция, корректно вычисляющая $g$ более чем на $7/8$ входов, не
является функцией от $\xi$ двух своих входных бит.
\end{proposition}

\begin{proof}
Пусть функция $g'(x, y)$ корректно вычисляет $g(x, y)$ на более, чем $7/8$ доле
всех $\{0, 1\}^{2n}$ входов.

Обозначим для удобства элементы матрицы $A_L$ как $\{a_{i, j}\}_{(i, j) \in {[n]^2}}$.

Рассмотрим два любых входных бита функции $g(x, y)$. Рассмотрим несколько
возможных случаев того, каким из входных векторов $x$ и $y$ функции $g$ они
принадлежат.
\begin{description}
\item{Биты "--- это $x_i$ и $x_j$.} У строк $i$ и $j$ матрицы $A_L$ обязательно
найдётся позиция (столбец), в которой они отличаются. Обозначим номер такого
столбца как $\delta$, а соответствующую столбцу переменную "--- как $y_\delta$.
Не теряя общности, будем считать, что в позиции $\delta$ строка $i$ имеет ноль,
а строка $j$ "--- единицу: $a_{i, \delta} = 0, a_{j, \delta} = 1$.

Ясно, что найдётся какая-то подстановка $\rho$, которая фиксирует все входные
переменные $g$, кроме $x_i, x_j, y_\delta$ так, что при этом $g' \rvert _ \rho$
корректно вычисляет $g \rvert _ \rho$ на более чем $7/8$ доле входов $\{0,
1\}^3$. Покажем, что $g' \rvert _ \rho$ не может быть функцией от $\xi$ двух своих
входных битов.

Поймём, какой вид будет иметь $g \rvert _ \rho$. 
\[
g(x, y) = \sum_{i', j'} a_{i', j'} x_{i'} y_{j'} + \sum_{i'} u_{i'} x_{i'} + \sum_{j'} v_{j'} y_{j'}.
\]
Если зафиксировать $\rho$, то получится (помним, что $a_{i, \delta} = 0, a_{j, \delta} = 1$)
\[
g \rvert _ \rho (x_i, x_j, y_\delta) = x_j y_\delta + x_i b_i + x_j b_j + y_\delta c_\delta + d,
\]
где $b_i, b_j, c_\delta$ и $d$ "--- это константы, которые получаются от
фиксирования входов $g$.

Уже сейчас можно понять, что такую функцию $g \rvert _ \rho$ нельзя вычислить на
более чем $7/8$ входов функцией от $\xi(x_i, x_j)$ ни при каких значениях констант
$b_i$, $b_j$, $c_\delta$ и $d$.

% Но убедимся в этом по-честному.
% Не теряя общности, можно считать, что константа $d = 0$.

\item{Биты "--- это $y_i$ и $y_j$.} Этот случай симметричен предыдущему.
\item{Биты "--- это $x_i$ и $y_j$.} Так как $A_L$ имеет одну строку и один
столбец, полностью состоящие из единиц, либо в строке $i$, либо в столбце $j$
найдётся единица на позиции, отличной от $(i, j)$. Не теряя общности будем
считать, что такая единица нашлась в столбце $j$ и расположена в клетке $(i',
j)$.

Аналогично предыдущему пункту выберем такую подстановку $\rho$ всех переменных,
кроме $x_i, x_{i'}, y_j$, чтобы $g \rvert _ \rho$ и $g' \rvert _ \rho$ совпадали
не менее, чем на $7/8$ входов.

Обозначив для краткости $a := a_{i, j}$, получим следующее выражение для $g
\rvert _ \rho$.
\[
g \rvert _ \rho (x_i, x_{i'}, y_j) = a x_i y_j + x_{i'} y_j + x_i b_i + x_{i'} b_{i'} + y_j c_j + d,
\]
где $b_{i}, b_{i'}, c_j$ и $d$ "--- константы.

Легко проверить вручную, что такая никакая функция, вычисляющая эту верно более
чем на $7/8$ доле входов, не может быть функцией от $\xi(x_i, y_j)$ ни при каких
значениях констант $b_{i}, b_{i'}, c_j$ и $d$.
\end{description}

(В том, что утвеждения из пунктов выше выполняются для $g \rvert _ \rho$, можно
убедиться вручную. У меня это получилось сделать только разбором случаев по
значениям констант. Либо можно перебрать программой все значения констант.)
\end{proof}

\begin{proposition} \label{single_one}
Пусть матрица $M$ имеет единицу в клетке $(i, j)$, а $u$ и $v$ "--- произвольные
вектора.

Тогда любая функция, вычисляющая $g(x, y) = x^\top A y + u^\top x + v^\top y$ на
$> 3/4$ доле входов, обязана зависеть от $x_i$ и от $y_j$.
\end{proposition}
\begin{proof}
Докажем, что $g$ обязана зависеть от $x_i$, а для $y_i$ доказательство будет
симметричным.

Пусть $g'(x, y)$ вычисляет $g(x, y)$ на $> 3/4$ доле входов. Ясно, что можно
зафиксировать все входные переменные этих функций, кроме $x_i$ и $y_j$, таким
образом, чтобы после фиксирования эти функции по-прежнему совпадали на $> 3/4$
доле входов. Обозначим такую подстановку как $\rho$.

Так как у функции $g \rvert _ \rho$ два входных бита: $x_i$ и $y_j$, которые
могут принимать всего $4$ значения, любая $g' \rvert _ \rho$, вычисляющая
её на $> 3/4$ доле входов обязана вычислять её коррекно на всех входах. Заметим,
что функция $g \rvert _ \rho(x_i, y_j)$ является многочленом с коэффициентом $1$
при $x_i y_j$:
\[
\begin{aligned}
&g \rvert _ \rho (x_i, y_j) = x_i y_j + a x_i + b y_j + c,
&
\text{где $a, b, c \in \{0, 1\}$.}&
\end{aligned}
\]
По этому выражению ясно, что никакая функция $g' \rvert _ \rho$, не зависящая от
$x_i$, не может вычислить $g \rvert _ \rho$ корректно на всех входах.

Значит, не существует не зависящей от $x_i$ функции $g'$, которая вычисляла бы
$g$ верно на $> 3/4$ доле входов.
\end{proof}

\begin{theorem} \label{main}
При $n = 1 + \sum l_i \geq 2$ для любых $u, v \in \{0, 1\}^n$ функция
\[
g_n(x, y) = x^\top A_L y + u^\top x + v^\top y
\]
не может быть вычислена на более чем $7/8$ входов схемой размера менее $3n -
\max \{l_i\} - 5$. То же самое другими словами:
\[
C_{7/8}(g_n) \geq 3n - \max \{l_i\} - 5.
\]
\end{theorem}
\begin{proof}
Индукция по $n$.

\emph{База $n = 2$}. Очевидно, $C_{7/8}(g_n) \geq 0$.

\emph{Переход $n > 2$.} Рассмотрим любую функцию $g'_n$, которая корректно
вычисляет $g_n$ на более чем $7/8$ доле входов. Рассмотрим схему минимального
размера для $g'_n$. Обозначим первый гейт этой схемы в порядке топологической
сортировки как $\xi$. На вход $\xi$ подаются два входа схемы. По предложению \ref{tough}
один из этих входов должен подаваться на какой-то ещё гейт схемы. Зафиксируем
этот вход схемы $z_1$ в значение $b_1$, удалив из схемы два гейта. Если $g'_n$
вычисляла $g_n$ на $> 7/8$ доле входов, то можно выбрать $b_1$ так, чтобы
$g'_n \rvert_{z_1 = b_1}$ вычисляла $g_n \rvert_{z_1 = b_1}$ на $ > 7/8$ доле входов.

Такое фиксирование удалит либо одну строку, либо столбец из матрицы $A_L$. Не
теряя общности, будем считать, что была удалена строка. Обозначим её номер как
$i$. По предложению \ref{easy} найдётся столбец $j$, такой что после удаления
строки $i$ и столбца $j$ из матрицы $A_L$ получится $A_{L'}$, где $L' = L - e_r$
для некоторого $r$.

Для удаления столбца $j$ из матрицы, полученной после фиксирования $z_1$,
зафиксируем соответствующий ему входной бит. Обозначим этот бит как $z_2$, а
значение, в которое его зафиксируем, как $b_2$. Значение $b_2$ можно выбрать
таким образом, чтобы $g'_n \rvert _ {z_1 = b_1, z_2 = b_2}$ верно вычисляла
$g_n \rvert _ {z_1 = b_1, z_2 = b_2}$ на $> 7/8$ входов.

Напомним, что $L = (l_1, \dots l_k)$. Рассмотрим два случая.
\begin{itemize}
\item Если $k \geq 2$, то после удаления строки $i$ в каждом столбце останется
как минимум одна единица. Поэтому из предложения \ref{single_one} следует, что
$g' \rvert _ {z_1 = b_1}$ зависит от $z_2$. А это значит, что при фиксировании
$z_2 = b_2$ из схемы удалится как минимум один гейт. В этом случае, мы удалили
три гейта из схемы, поэтому $C(g' \rvert _ {z_1 = b_1, z_2 = b_2}) \leq C(g') - 3$
и уменьшили одно из значений $l_i$ на единицу. По индукционному предположению
\[
\begin{aligned}
C(g' \rvert _ {z_1 = b_1, z_2 = b_2}) &\geq 3(n - 1) - \underbrace{\max \{l_i'\}}_{\leq \max \{l_i\}} - 5 \\
&\geq 3(n - 1) - \max \{l_i\} - 5.
\end{aligned}
\]
Отсюда получаем требуемое утверждение:
\[
\begin{aligned}
C_{7/8}(g) &\geq C(g' \rvert _ {z_1 = b_1, z_2 = b_2}) + 3 \\
           &\geq 3n - \max \{l_i\} - 5.
\end{aligned}
\]

%% TODO: Заменить C на C_{7/8} в этом доказательстве

\item Если $k = 1$. В этом случае после фиксирования $z_2 = b_2$ из схемы могло
ничего и не удалиться. Но всё равно мы удалили из схемы как минимум два гейта
фиксированием $z_1 = b_1$. Поэтому аналогично предыдущему пункту верно $C(g'
\rvert _ {z_1 = b_1, z_2 = b_2}) \leq C(g') - 2$, к тому же по индукционному
предложению
\[
\begin{aligned}
C(g' \rvert _ {z_1 = b_1, z_2 = b_2}) &\geq 3(n - 1) - \underbrace{\max \{l_i'\}}_{\max \{l_i\} - 1} - 5 \\
&= 3(n - 1) - \max \{l_i\} + 1 - 5.
\end{aligned}
\]
Получаем требуемое утверждение:
\[
\begin{aligned}
C_{7/8}(g) &\geq C(g' \rvert _ {z_1 = b_1, z_2 = b_2}) + 2 \\
           &\geq 3n - \max \{l_i\} - 5.
\end{aligned}
\]
\end{itemize}
\end{proof}

\section{Следствия и конструкции}
Обозначим символом $M_{n, t}$ матрицу $A_L$, где вектор $L = \{l_1 \dots l_t\}$.
Сумма компонент $L$ равна $n - 1 = \sum l_i$, а значения компонент отличаются
максимум на единицу: $l_i \in \left \{ \floor{\frac {n - 1} t}, \ceil{\frac {n -
1} t} \right\}$.

Следующее является следствием теоремы \ref{main}.

\begin{corollary}
Для $g_{n, t}(x, y) = x^\top M_{n, t} y$ верно
\[
C_{7/8}(g_{n, t}) \geq 3n - \ceil*{\frac {n - 1} t} - 5.
\]
\end{corollary}

% TODO: Показать здесь M^{-1}_{n, t}

В работе Хильтгена \cite[определение 8]{hiltgen1993} построена такая
односторонняя функция $\lambda_{n, t}$ и доказана следующая теорема о её
сложности.

\begin{theorem}[Хильтген]
Пусть $\lambda_{n, t}(x) = M_{n, t}^{-1} x$, а $\lambda^{-1}_{n, t}(x) = M_{n,
t} x$, тогда
\[
n \leq C(\lambda_{n, t}) \leq n + t - 1 \quad \quad C(\lambda_{n, t}^{-1}) = \floor*{ \frac {2t - 1} t (n - 1) }
\]
\end{theorem}

Теперь можно выбрать в качестве односторонней функции
\[
f_{n,t}(x, y) = (x, \lambda_{n, t}(y)),
\]
а в качестве трудного бита для неё скалярное произведение $h_n(x, y) = x^\top y$.
Тогда функция
\[
g_{n, t}(x, y) = (h \circ f_{n, t}^{-1})(x, y) = x^\top M_{n, t} y
\]
окажется как раз той функцией, которую
должен вычислить атакующий, которому известно значение односторонней функции
$f_{n, t}(x, y)$ и который хочет вычислить $h_n(x, y)$.

Теперь, выбирая конкретные значения для $t$, построим несколько односторонних
функций с трудным битом. (Помним, что $C(h_n) = 2n - 1$ и не зависит от $t$.)
\begin{description}
\item[$t = 2$.] В этом случае получается слабо надёжная односторонная функция
порядка $3/2$ из работы \cite{hiltgen1993} и слабо надёжный трудный бит для
неё порядка $(3 - 1/2) / 2 = (1 + 1/4)$ с вероятностью $7/8$.
\[
\begin{aligned}
C(f_{n, t}) &\leq n + 1 \\
C(f_{n, t}^{-1}) &\geq \frac 3 2 (n - 1) \\
C(g_{n, t}) &\geq (3 - \frac 1 2)n - 6. \\
\end{aligned}
\]
\item[$t = n - 1$.] Это крайний случай, здеь получается, что $f_{n, t}$ так же
легко обратить, как и вычислить, но оценка на $C(g)$ получается самая лучшая:
\[
\begin{aligned}
C(f_{n, t}) &\leq 2n - 2 \\
C(f_{n, t}^{-1}) &\geq 2n - 3 \\
C(g_{n, t}) &\geq 3n - 6. \\
\end{aligned}
\]
$f_{n,t}$ "--- слабо надёжная односторонняя функция порядка $1$, а $h_{n}$ "---
трудный бит для неё порядка $1 + 1/2$ с вероятностью $7/8$.
\item[$t = \sqrt{n}$.] В этом случае получаются асимптотически наилучшие
соотношения между сложностями функций:
\[
\begin{aligned}
C(f_{n, t}) &\leq n + \sqrt{n} - 1 \\
C(f_{n, t}^{-1}) &\geq 2n - \sqrt n - 3 \\
C(g_{n, t}) &\geq 3n - \sqrt{n} - 6. \\
\end{aligned}
\]
Функция $f_{n, t}$ является слабо односторонней порядка $2$, а $h_{n}$
является трудным битом для неё поряка $1 + 1/2$ с вероятностью $7/8$.
\end{description}

\bibliography{main}{}
\bibliographystyle{plain}

\end{document}
